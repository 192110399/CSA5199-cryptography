def mod_inverse(a, m):
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def matrix_multiplication(matrix1, matrix2):
    result = []
    for i in range(len(matrix1)):
        row = []
        for j in range(len(matrix2[0])):
            sum = 0
            for k in range(len(matrix2)):
                sum += matrix1[i][k] * matrix2[k][j]
            row.append(sum)
        result.append(row)
    return result

def hill_cipher_encrypt(plain_text, key_matrix):
    plain_text = plain_text.upper().replace(' ', '') 
    n = len(plain_text)
    if n % 3 != 0:
        plain_text += 'X' * (3 - (n % 3))  
    plain_text_indices = [ord(char) - ord('A') for char in plain_text]
    encrypted_text = ''
    for i in range(0, n, 3):
        char_indices = plain_text_indices[i:i+3]
        encrypted_indices = matrix_multiplication(key_matrix, [char_indices])
        encrypted_indices = [idx % 26 for idx in encrypted_indices[0]]
        encrypted_text += ''.join([chr(idx + ord('A')) for idx in encrypted_indices])
    return encrypted_text

# Example usage:
plain_text = input("Enter text to encrypt: ")
key_matrix = [[17, 17, 5], [21, 18, 21], [2, 2, 15]]  
encrypted_text = hill_cipher_encrypt(plain_text, key_matrix)
print("Encrypted text:", encrypted_text)
